#### SPEC 1

always assume {
  // Assumptions for iterating over the grid using nextIndex
  ([ index <- nextIndex(grid.index) ] -> (!isFinished(grid.index) W isFinished(grid.index)));

  // If the current index is the last index of the grid, then reset the index pointer and increment rounds
  (isFinished(grid.index) -> ([ index <- resetIndex(index) ] && [ grid.rounds <- newRound(grid.rounds) ]));
}

always guarantee {
  // Guarantees for the state of each cell based on its neighbors

  // A dead cell will come alive if exactly 3 neighbours are living
  (!isAlive(grid.index) && comeAlive(grid.index) -> [ grid.index <- changeAlive(grid.index) ]);

  // A living cell will stay alive if 2 or 3 neighbours are living
  (isAlive(grid.index) && stayAlive(grid.index) -> [ grid.index <- grid.index ]); // Implicitly indicates no change

  // Cells with less than 2 or more than 3 neighbours will die
  (isAlive(grid.index) && comeDead(grid.index) -> [ grid.index <- changeAlive(grid.index) ]);

  // Rounds are incremented and index is reset at the end of each round
  (isFinished(grid.index) -> ([ index <- resetIndex(index) ] && [ grid.rounds <- newRound(grid.rounds) ]));
}


#### SPEC 2

always assume {
  // Iteration over the grid
  ([ index <- nextIndex(grid.index) ] -> (!isFinished(grid.index) W isFinished(grid.index)));
  (isFinished(grid.index) -> ([ index <- resetIndex(index) ] && [ grid.rounds <- newRound(grid.rounds) ]));
  
  // Ensure mutual exclusivity for cell states
  // Assuming additional predicates/functions could help clarify this
}

always guarantee {
  // Cell state transitions
  (!isAlive(grid.index) && comeAlive(grid.index) -> [ grid.index <- changeAlive(grid.index) ]);
  (isAlive(grid.index) && stayAlive(grid.index) -> [ grid.index <- grid.index ]); // Implicitly indicates no change
  
  // Cell dies from underpopulation or overpopulation
  (isAlive(grid.index) && comeDead(grid.index) -> [ grid.index <- changeAlive(grid.index) ]);
  
  // Ensure the game progresses correctly
  (isFinished(grid.index) -> ([ index <- resetIndex(index) ] && [ grid.rounds <- newRound(grid.rounds) ]));
}
