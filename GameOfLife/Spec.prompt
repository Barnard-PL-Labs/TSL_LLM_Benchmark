
Translate the following into a TSL specification. Remember, this is what TSL code looks like:

```
always assume {
  (room.somebodyEnters
    -> (! room.empty W room.somebodyLeaves)) ;
  ((room.somebodyLeaves && room.empty)
    -> (room.empty W room.somebodyEnters)) ;
  (cm.ready || cm.standby || cm.busy) ;
  (cm.ready -> (!cm.standby && !cm.busy)) ;
  (cm.standby -> (!cm.busy && !cm.ready)) ;
  (cm.busy -> (!cm.ready && !cm.standby)) ;
  ([ cm.ctrl <- turnOn() ] && cm.standby
    -> X cm.busy U ([ cm.ctrl <- makeCoffee() ] || [ cm.ctrl <- turnOff() ] R cm.ready)) ;
  ([ cm.ctrl <- turnOff() ] && cm.ready
    -> X cm.busy U ([ cm.ctrl <- turnOn() ] R cm.standby)) ;
  ([ cm.ctrl <- makeCoffee() ] && cm.ready
    -> X cm.busy U (cm.finished && ([ cm.ctrl <- makeCoffee() ] || [ cm.ctrl <- turnOff() ] R cm.ready)));
 }
always guarantee {
  room.somebodyEnters
    -> F (cm.ready W (room.somebodyLeaves && room.empty));
}
```

```
  always assume {
    //mutual exculsion for all key inputs
   ! (pressL(e) && pressR(e));
   ! (pressL(e) && pressUp(e));
   ! (pressL(e) && pressDown(e));
   ! (pressR(e) && pressUp(e));
   ! (pressR(e) && pressDown(e));
   ! (pressUp(e) && pressDown(e));
  }

always guarantee {
    //mutual exclusion for X and Y pos updates, only one is updated at a time
    pressL(e) -> (([ headX <- headX - 1] && [headY <- headY]) W (pressR(e) || pressDown(e) || pressUp(e)));
    pressR(e) -> (([ headX <- headX + 1] && [headY <- headY]) W (pressL(e) || pressDown(e) || pressUp(e)));
    pressUp(e) -> (([ headY <- headY - 1] && [headX <- headX]) W (pressR(e) || pressL(e) || pressDown(e)));
    pressDown(e) -> (([ headY <- headY + 1] && [headX <- headX]) W (pressR(e) || pressL(e) || pressUp(e))); 
}
```

```
always assume {
  //mutual exclusion for inputs
  !(eatFood && hitSelf && hitWall);
}

always guarantee {
  //if an apple is eaten: increment the score and snake length, also reset apple position to a random value
  eatFood -> ([score <- score + 1] && [tailLength <- tailLength + 1] && [appleX <- randX] && [appleY <- randY]);
	
  //if self or wall is hit: signal game over
  (hitSelf || hitWall) -> [command <- die];
	
  //if there are no collisions, nothing should change
  ! (eatFood || hitSelf || hitWall) -> ([score <- score] && [tailLength <- tailLength] && [appleX <- appleX] && [appleY <- appleY] && [command <- idle]);
}
```

Remember this is the documentation for TSL: https://www.notion.so/flaneurnah/TSL-Documentation-90fec2187e7042b2ad16a53f59251c53#5361d4438fad4c5aba36be03f52ef20a
You should not need to use '==' in the TSL spec.

This is a complete listing of all functions and predicates you will need to use to create the spec. Everything else should be basic TSL language operators.

Cells:
  "grid" is a cell that stores the entire grid that the game of life is played on as a 2d array where cells are either 1 or 0. Each round the grid is updated as the game progresses.
  "grid.index" is a cell that stores the current index that the state machine is observing on the grid.
  "grid.rounds" is a cell that stores how many rounds the game has been played
Functions:
  nextIndex(grid.index) => moves the index variable to the next valid index in the grid
  changeAlive(grid.index) => changes a the state of a specific index at the grid
  newRound(rounds) => increments the number of rounds by 1 may be called after checking if we are at the last index of the grid
  resetIndex(index) => resets the index cell to point to the start of the grid for the next round
Predicates:
  comeAlive(grid.index) => are exactly 3 neighbours are living?
  stayAlive(grid.index) => are 2 or 3 neighbours are living?
  comeDead(grid.index) => does the cell have less than 2 neighbours or more than 3 neighbours?
  isFinished(grid.index) => Is the index the last index on the grid?

Natural language description: Game of Life

Every cell observes its surrounding neighbours to check whether its living area is underpopulated, overpopulated or suitable to live in. Each cell has 8 neighbours (except for the ones at the edge of the canvas).

Assumptions:

1. The grid is iterated over using nextIndex

2. If the current index is the last index of the grid, then the index pointer is reset to the beginning

3. At each grid index a cell can use the predicate functions to check what it's new state should be

4. The current grid cell looks at all of it's neighbors to determine it's own state

5. Rounds is incremented using newRound at the end of each round

Guarantees:

1. A dead cell will come alive if exactly 3 neighbours are living

2. A living cell will stay alive if 2 or 3 neighbours are living

3. Cells with less than 2 neighbours will die of underpopulation

4. cells with 4 or more neighbours will die of overpopulation

5. A grid cell can not be on and off at the same time