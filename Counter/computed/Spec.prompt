Translate the following into a TSL specification. Remember, this is what TSL code looks like:

```
always assume {
  // Handling button presses and ensuring only one button action occurs at a time
  (pressD(e) -> ! (pressQ(e) || pressO(e) || press1(e) || press2(e) || press3(e) || pressR(e))) ;
  (pressQ(e) -> ! (pressD(e) || pressO(e) || press1(e) || press2(e) || press3(e) || pressR(e))) ;
  (pressO(e) -> ! (pressD(e) || pressQ(e) || press1(e) || press2(e) || press3(e) || pressR(e))) ;
  (press1(e) -> ! (pressD(e) || pressQ(e) || pressO(e) || press2(e) || press3(e) || pressR(e))) ;
  (press2(e) -> ! (pressD(e) || pressQ(e) || pressO(e) || press1(e) || press3(e) || pressR(e))) ;
  (press3(e) -> ! (pressD(e) || pressQ(e) || pressO(e) || press1(e) || press2(e) || pressR(e))) ;
  (pressR(e) -> ! (pressD(e) || pressQ(e) || pressO(e) || press1(e) || press2(e) || press3(e))) ;

  // Check the conditions for allowing a purchase
  (press1(e) -> isLessThanPoint75(total)) ;
  (press2(e) -> isLessThanOne(total)) ;
  (press3(e) -> isLessThanOnePoint25(total)) ;
}

always guarantee {
  // Updating the total value based on button presses
  pressD(e) -> [ total <- total + 0.1 ] ;
  pressQ(e) -> [ total <- total + 0.25 ] ;
  pressO(e) -> [ total <- total + 1 ] ;

  // Handling product selection and refunds
  press1(e) && isLessThanPoint75(total) -> [ total <- total - 0.75 ] ;
  press2(e) && isLessThanOne(total) -> [ total <- total - 1 ] ;
  press3(e) && isLessThanOnePoint25(total) -> [ total <- total - 1.25 ] ;
  pressR(e) -> [ total <- 0 ] ;
}
```

This is a complete listing of all functions and predicates you will need to use to create the spec. Everything else should be basic TSL language operators.

Cells: 
    "stepsize" is a cell that represents the state of the signal that determines how much the counter will increment by when pressing the "a" key/button.
    "e" is a cell that represents the state of the signal that determines how the counter should act (how much it should increment by based on which key is pressed).

Functions:

Predicates:
    pressA(e) => did the user press the a key?
    pressB(e) => did the user press the b key?
    pressC(e) => did the user press the c key?


Natural language description:

Use the metaphor of a user pushing buttons with the result that clicking a certain button will increment the counter by a certain amount each time. The button choices are the A key, B key, and C key. Pressing the A key increments the counter by stepsize. Pressing the B key increments the counter by 2. Pressing the B key increments the counter by 3. Pressing the A key 3 times in a row changes its stepsize by 3 times what it was before, unless the B key or C key are pressed which resets the stepsize to 1. No two counter (button) operations can be performed at the same time.



Assumptions:

1. There are three buttons, named pressA, pressB, and pressC, which can be pushed by the user.

Guarantees:

2. When pressA is pushed, the system ensures that the counter will be incremented by stepsize. This is achieved by writing the value "count + stepsize" to the variable "count".

3. When pressB is pushed, the system ensures that the counter will be incremented by 2. This is achieved by writing the value "count + 2" to the variable "count".

4. When pressC is pushed, the system ensures that the counter will be incremented by 3. This is achieved by writing the value "count + 3" to the variable "count".

5. When pressA is pushed three times in a row, on the fourth time in a row that it is clicked, it will increase the counter by what stepsize is times three. This is achieved by writing the value "multiplyByThree(stepsize)" to the variable "stepsize".

6. When pressB or pressC is pushed, the systems ensures that the stepsize will be set back to 1. This is achieved by writing the value "1" to the variable "stepsize".