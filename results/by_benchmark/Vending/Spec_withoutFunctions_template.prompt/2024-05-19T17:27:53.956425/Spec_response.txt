Here's the TSL specification for the vending machine scenario provided:

```
always assume {
  // Mutual exclusion for button presses: no two machine operations can be performed at the same time
  !(pressD(e) && (pressQ(e) || pressO(e) || press1(e) || press2(e) || press3(e) || pressR(e)));
  !(pressQ(e) && (pressD(e) || pressO(e) || press1(e) || press2(e) || press3(e) || pressR(e)));
  !(pressO(e) && (pressD(e) || pressQ(e) || press1(e) || press2(e) || press3(e) || pressR(e)));
  !(press1(e) && (pressD(e) || pressQ(e) || pressO(e) || press2(e) || press3(e) || pressR(e)));
  !(press2(e) && (pressD(e) || pressQ(e) || pressO(e) || press1(e) || press3(e) || pressR(e)));
  !(press3(e) && (pressD(e) || pressQ(e) || pressO(e) || press1(e) || press2(e) || pressR(e)));
  !(pressR(e) && (pressD(e) || pressQ(e) || pressO(e) || press1(e) || press2(e) || press3(e)));
}

always guarantee {
  // Increment total when money is inserted
  pressD(e) -> [total <- total + 0.1];
  pressQ(e) -> [total <- total + 0.25];
  pressO(e) -> [total <- total + 1];

  // Decrement total when a product is purchased, if enough credit is available
  press1(e) -> (isLessThanPoint75(total) -> [total <- total - 0.75]);
  press2(e) -> (isLessThanOne(total) -> [total <- total - 1]);
  press3(e) -> (isLessThanOnePoint25(total) -> [total <- total - 1.25]);

  // Refund money
  pressR(e) -> [total <- 0];
}
```

This TSL specification captures:
1. The mutual exclusion of button presses, ensuring that no two machine operations can be performed simultaneously.
2. Updating the 'total' variable appropriately when money is inserted or products are purchased, based on the amount already accrued in the machine.
3. Resetting the 'total' variable to zero when the refund button is pressed.

Note that the logical conditions for purchasing products (press1, press2, press3) are written with the implication arrow (`->`) such that the decrement occurs only if the condition of having sufficient funds is met.