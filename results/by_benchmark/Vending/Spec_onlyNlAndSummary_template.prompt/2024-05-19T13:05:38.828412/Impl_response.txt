Given the predicates that need to be implemented and the lack of specific API functions, we can assume direct access to the properties of the "total" and "e" cells. Here's how you can structure the TSL predicates based on the problem description:

```tsl
always assume {
  // Define predicates related to the "total" cell
  isLessThanPoint75(total) <-> (total < 0.75);
  isLessThanOne(total) <-> (total < 1);
  isLessThanOnePoint25(total) <-> (total < 1.25);

  // Define predicates based on the "e" cell for detecting key presses
  pressD(e) <-> (e == 'd');
  pressQ(e) <-> (e == 'q');
  pressO(e) <-> (e == 'o');
  press1(e) <-> (e == '1');
  press2(e) <-> (e == '2');
  press3(e) <-> (e == '3');
  pressR(e) <-> (e == 'r');
}
```

### Explanation:
- The predicates `isLessThanPoint75`, `isLessThanOne`, and `isLessThanOnePoint25` are defined to check if the value of `total` is less than 0.75, 1, and 1.25, respectively.
- The predicates `pressD`, `pressQ`, `pressO`, `press1`, `press2`, `press3`, and `pressR` determine if a specific key (represented by a character) has been pressed according to the state of `e`.

### Note:
- In TSL, the `<->` operator is used to define equivalences, meaning the predicate holds exactly when the condition on the right side of the operator is true.
- The exact mechanism of how keys are represented (e.g., ASCII values, direct character representation) in `e` should align with your system's implementation details. Adjustments might be needed if keys are not directly represented as characters.
- Ensure the values within predicates (like `'d'`, `'q'`, etc.) match the actual possible values of `e` in your specific system context.