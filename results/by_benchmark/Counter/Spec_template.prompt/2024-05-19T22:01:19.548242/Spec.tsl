always assume {
    // Ensuring that no two button presses overlap
    !(pressA(e) && pressB(e));
    !(pressA(e) && pressC(e));
    !(pressB(e) && pressC(e));
}

always guarantee {
    // Handling the counter increment when the A key is pressed
    pressA(e) -> ([count <- count + stepsize] W (pressB(e) || pressC(e)));
    
    // If A is pressed three times consecutively, multiply stepsize by three
    // This is conceptually handled; actual implementation may require additional state tracking
    pressA(e) && X(pressA(e)) && X(X(pressA(e))) -> [stepsize <- multiplyByThree(stepsize)] W (pressB(e) || pressC(e));
    
    // Handling the counter increment when the B key is pressed
    pressB(e) -> {
        [count <- count + 2];
        [stepsize <- 1]; // Reset stepsize to 1
    }
    
    // Handling the counter increment when the C key is pressed
    pressC(e) -> {
        [count <- count + 3];
        [stepsize <- 1]; // Reset stepsize to 1
    }
}
