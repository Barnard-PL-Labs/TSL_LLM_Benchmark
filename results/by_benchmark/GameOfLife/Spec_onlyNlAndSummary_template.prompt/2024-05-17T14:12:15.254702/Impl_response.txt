To implement the requested functions and predicates in JavaScript for a cell-based system (similar to Conway's Game of Life), you'll first need to establish the logic for determining the state of a cell based on its neighbors. Below, I will provide a JavaScript implementation that assumes you have a grid layout and each cell in that grid can be identified by an index. We'll create a class to manage the grid and include methods for the functions and predicates specified.

### Step 1: Define the Grid Class
This class will hold the grid state and include methods to change state, determine if a cell should come alive, or die.

```javascript
class Grid {
    constructor(size) {
        this.size = size;
        this.grid = new Array(size * size).fill(false); // Initialize a grid of given size, fill with 'false' indicating all cells are dead.
    }

    // Helper method to calculate number of alive neighbours
    countAliveNeighbours(index) {
        let aliveCount = 0;
        let x = index % this.size;
        let y = Math.floor(index / this.size);
        
        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                if (dx === 0 && dy === 0) continue; // skip the cell itself
                
                let nx = x + dx;
                let ny = y + dy;

                if (nx >= 0 && nx < this.size && ny >= 0 && ny < this.size) {
                    if (this.grid[ny * this.size + nx]) {
                        aliveCount++;
                    }
                }
            }
        }
        return aliveCount;
    }

    // Predicate to determine if a cell should come alive
    comeAlive(index) {
        const aliveNeighbours = this.countAliveNeighbours(index);
        return aliveNeighbours === 3 || (this.grid[index] && (aliveNeighbours === 2 || aliveNeighbours === 3));
    }

    // Predicate to determine if a cell should die
    comeDead(index) {
        const aliveNeighbours = this.countAliveNeighbours(index);
        return aliveNeighbours < 2 || aliveNeighbours > 3;
    }

    // Function to change the state of the grid
    changeState() {
        const newGrid = new Array(this.size * this.size).fill(false);
        for (let i = 0; i < this.grid.length; i++) {
            if (this.comeAlive(i)) {
                newGrid[i] = true;
            } else if (this.comeDead(i)) {
                newGrid[i] = false;
            } else {
                newGrid[i] = this.grid[i];
            }
        }
        this.grid = newGrid;
    }
}
```

### Step 2: Using the Grid Class
To use this `Grid` class, you might instantiate a grid, modify its state based on some initial conditions, and then use `changeState` method to evolve the grid state over time.

```javascript
let grid = new Grid(10); // Create a 10x10 grid
grid.grid[5 * 10 + 5] = true; // Set cell at index 55 to alive
grid.grid[5 * 10 + 6] = true; // Set cell at index 56 to alive
grid.grid[5 * 10 + 7] = true; // Set cell at index 57 to alive
grid.changeState(); // Compute the next state of the grid
```

The presented code initializes and manipulates a grid system based on Conwayâ€™s Game of Life rules, updating each cell's state according to the rules defined in `comeAlive` and `comeDead` predicates. Adjustments may be needed based on the actual API specifications and additional requirements.