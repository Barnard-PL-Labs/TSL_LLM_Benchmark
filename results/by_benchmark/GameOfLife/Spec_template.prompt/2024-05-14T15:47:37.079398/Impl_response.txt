It appears you want to implement a simulation akin to Conway's Game of Life, where cells on a grid can either be alive or dead and their state in the next generation depends on the number of live neighbors they have. Here's how you can implement this in JavaScript using the provided API and specifications.

### JavaScript Implementation

First, let's define the basic structure and the API interactions:

```javascript
class Cell {
  constructor(index, alive = false) {
    this.index = index;
    this.alive = alive;
  }

  changeState() {
    this.alive = !this.alive;
  }
}

class Grid {
  constructor(size) {
    this.size = size;
    this.cells = Array.from({ length: size * size }, (_, index) => new Cell(index));
    this.neighborOffsets = [-1, 0, 1];
  }

  getCell(index) {
    return this.cells[index];
  }

  getNeighbors(index) {
    const x = index % this.size;
    const y = Math.floor(index / this.size);
    let neighbors = [];

    this.neighborOffsets.forEach(dx => {
      this.neighborOffsets.forEach(dy => {
        if (dx === 0 && dy === 0) return;
        const nx = x + dx;
        const ny = y + dy;
        if (nx >= 0 && nx < this.size && ny >= 0 && ny < this.size) {
          neighbors.push(this.cells[ny * this.size + nx]);
        }
      });
    });

    return neighbors;
  }

  countAliveNeighbors(index) {
    const neighbors = this.getNeighbors(index);
    return neighbors.filter(cell => cell.alive).length;
  }
}

// Predicates
function comeAlive(cellIndex, grid) {
  const aliveNeighbors = grid.countAliveNeighbors(cellIndex);
  const cell = grid.getCell(cellIndex);
  return !cell.alive && aliveNeighbors === 3;
}

function comeDead(cellIndex, grid) {
  const aliveNeighbors = grid.countAliveNeighbors(cellIndex);
  const cell = grid.getCell(cellIndex);
  return cell.alive && (aliveNeighbors < 2 || aliveNeighbors > 3);
}

// System simulation setup
const gridSize = 10;  // Assuming a 10x10 grid
const gameGrid = new Grid(gridSize);

// Example to toggle cell state
function updateGrid(grid) {
  const cellsToChange = [];
  grid.cells.forEach((cell, index) => {
    if (comeAlive(index, grid) || comeDead(index, grid)) {
      cellsToChange.push(cell);
    }
  });

  // Update the cell states
  cellsToChange.forEach(cell => cell.changeState());
}
```

### Explanation

1. **Cell Class**: Represents each cell, holding its index and alive status. The `changeState` method toggles the cell's alive status.

2. **Grid Class**: Manages the grid of cells. It initializes cells, provides a method to fetch a specific cell, and counts alive neighbors for any given cell.

3. **comeAlive and comeDead Functions**: These are the predicates to determine whether a cell should come alive or die based on the number of alive neighbors.

4. **System Simulation**: A function `updateGrid` iterates over all cells, checks the conditions with the predicates, and updates the grid accordingly.

This implementation assumes that you have a periodic boundary condition (ignoring boundary checks for simplicity), and the grid's size is adjustable. Adjust the `gridSize` and logic as per your specific needs and boundary conditions.