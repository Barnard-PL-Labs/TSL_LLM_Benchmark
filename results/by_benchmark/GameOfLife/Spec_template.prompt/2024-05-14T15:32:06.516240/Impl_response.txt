To implement the described functions and predicates using JavaScript, we will first need to define and initialize a simple environment for our cellular automaton system, presumably modeling a version of Conway's Game of Life given the rules specified. Below is an implementation that handles this along with the required API methods:

```javascript
// Environment setup - assuming a grid size and initializing the state
const gridSize = 10; // Define grid size (10x10 for simplicity)
const grid = Array(gridSize).fill().map(() => Array(gridSize).fill(false)); // Initializes a 10x10 grid with false (dead cells)

// Helper function to count living neighbors
function countLivingNeighbors(x, y) {
    let livingNeighbors = 0;
    for (let i = -1; i <= 1; i++) {
        for (let j = -1; j <= 1; j++) {
            if (i === 0 && j === 0) continue; // Skip the cell itself
            const nx = x + i;
            const ny = y + j;
            if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize && grid[nx][ny]) {
                livingNeighbors++;
            }
        }
    }
    return livingNeighbors;
}

// Predicate: comeAlive
// Returns true if exactly 3 neighbors are living or if 2 or 3 neighbors are living
function comeAlive(x, y) {
    const neighbors = countLivingNeighbors(x, y);
    return (neighbors === 3) || (grid[x][y] && (neighbors === 2 || neighbors === 3));
}

// Predicate: comeDead
// Returns true if the cell has less than 2 neighbors or more than 3 neighbors
function comeDead(x, y) {
    const neighbors = countLivingNeighbors(x, y);
    return neighbors < 2 || neighbors > 3;
}

// Function: changeState
// Changes the state of the grid based on comeAlive and comeDead predicates
function changeState() {
    const newGrid = grid.map((row, x) => row.map((cell, y) => {
        if (comeAlive(x, y)) {
            return true; // Cell becomes alive or stays alive
        } else if (comeDead(x, y)) {
            return false; // Cell dies
        }
        return cell; // No change
    }));

    // Update the grid with the new state
    for (let x = 0; x < gridSize; x++) {
        for (let y = 0; y < gridSize; y++) {
            grid[x][y] = newGrid[x][y];
        }
    }
}

// Example usage:
changeState(); // Run the changeState function to update the grid based on the rules
console.log(grid); // Log the updated grid state
```

### Explanation

1. **Environment Setup**: We initialize a grid of a specified size filled with `false`, indicating all cells are initially dead.

2. **Helper Function**: `countLivingNeighbors(x, y)` calculates the number of living (true) neighbors around a specific cell.

3. **Predicates**:
   - `comeAlive(x, y)`: Returns `true` if a cell should come to life or stay alive based on its neighbors.
   - `comeDead(x, y)`: Determines if a cell should die based on the number of its neighbors.

4. **Function**:
   - `changeState()`: Applies the rules of the game to update the state of the grid based on the predicates.

This setup assumes a simple, non-periodic (non-wrapping) boundary condition on the grid. The grid and rules may need adjustments for different variants or boundary conditions of Conway's Game of Life or other cellular automata.